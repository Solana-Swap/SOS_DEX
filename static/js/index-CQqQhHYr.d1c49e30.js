import{by as p,bz as o,bA as s,bB as f,bC as O,bD as m,b2 as e,bE as A,bF as c}from"./Bridge.l6xugmfj.js";import"./index.ehffodxd.js";import"./vue.fv0erkdm.js";import"./lodash-es.bp0zmem9.js";import"./axios.i01mok01.js";import"./dayjs.pb8a0t5b.js";import"./vuex.jdzbw26m.js";import"./vue-router.jwqkmej7.js";import"./svg-icons.nw66rbkj.js";class b extends Error{constructor(r){super(r)}}class E extends b{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}const y=p([o("mintAuthorityOption"),s("mintAuthority"),f("supply"),O("decimals"),m("isInitialized"),o("freezeAuthorityOption"),s("freezeAuthority")]);y.span;async function C(t,r,i=!1,a=A,n=c){if(!i&&!e.isOnCurve(r.toBuffer()))throw new E;const[u]=await e.findProgramAddress([r.toBuffer(),a.toBuffer(),t.toBuffer()],n);return u}export{c as ASSOCIATED_TOKEN_PROGRAM_ID,y as MintLayout,A as TOKEN_PROGRAM_ID,b as TokenError,E as TokenOwnerOffCurveError,C as getAssociatedTokenAddress};
