import{A as O,S as A,a as V}from"./index-CglIP2bi.m6f9g1l6.js";import{dA as X,a4 as v,bT as Y,an as Z,a7 as L,dn as $,am as m,dB as W,ds as F,ca as ee,cn as b,cb as te,l as H,cg as K,dt as k,dq as l,du as x,dx as S,bN as D,dm as z,dC as se,dD as G,dE as oe}from"./Bridge.jzjokbd9.js";import{A as ne}from"./algorand-CbdjZ1lv.k0au7wuv.js";import"./index.bwmrk3ti.js";import"./vue.fv0erkdm.js";import"./lodash-es.bp0zmem9.js";import"./axios.i01mok01.js";import"./dayjs.pb8a0t5b.js";import"./vuex.jdzbw26m.js";import"./vue-router.jwqkmej7.js";import"./svg-icons.nw66rbkj.js";var re=Object.defineProperty,ae=(N,t,e)=>t in N?re(N,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):N[t]=e,c=(N,t,e)=>ae(N,typeof t!="symbol"?t+"":t,e);const J=X.fromSignature("portal_transfer(byte[])byte[]"),C=class f{constructor(t,e,n,o){if(c(this,"network"),c(this,"chain"),c(this,"connection"),c(this,"contracts"),c(this,"chainId"),c(this,"coreBridge"),c(this,"coreAppId"),c(this,"coreAppAddress"),c(this,"tokenBridgeAppId"),c(this,"tokenBridgeAddress"),this.network=t,this.chain=e,this.connection=n,this.contracts=o,this.chainId=L(e),!o.coreBridge)throw new Error(`Core contract address for chain ${e} not found`);const r=BigInt(o.coreBridge);if(this.coreAppId=r,this.coreAppAddress=$(r),this.coreBridge=new O(t,e,n,o),!o.tokenBridge)throw new Error(`TokenBridge contract address for chain ${e} not found`);const s=BigInt(o.tokenBridge);this.tokenBridgeAppId=s,this.tokenBridgeAddress=$(s)}static async fromRpc(t,e){const[n,o]=await ne.chainFromRpc(t),r=e[o];if(r.network!==n)throw new Error(`Network mismatch: ${r.network} != ${n}`);return new f(n,o,t,r.contracts)}async isWrappedAsset(t){const e=new m(t).toInt();if(e===0)return!1;const n=await this.connection.getAssetByID(e).do(),o=W.from_obj_for_encoding(n).params.creator,r=await this.connection.accountInformation(o).exclude("all").do(),s=F.from_obj_for_encoding(r);return(s==null?void 0:s.authAddr)===this.tokenBridgeAddress}async getOriginalAsset(t){const e=new m(t).toInt(),n=await this.connection.getAssetByID(e).do(),o=W.from_obj_for_encoding(n),r=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,o.params.creator);if(r.length<94)throw new Error("Invalid local state data");const s=r.slice(92,94),a=ee(b.decode(s)),p=new te(r.slice(60,92));return{chain:a,address:p}}async getTokenUniversalAddress(t){return new m(t).toUniversalAddress()}async getTokenNativeAddress(t,e){return new m(e).toNative()}async getWrappedAsset(t){if(H(t.address))throw new Error("native asset cannot be a wrapped asset");const e=A.forWrappedAsset(this.tokenBridgeAppId,t),n=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,e.address());if(n.length<8)throw new Error("Invalid wrapped asset data");return K(this.chain,b.decode(n.slice(0,8)).toString())}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedNative(){return K(this.chain,"0")}async isTransferCompleted(t){const e=A.forMessageId(this.tokenBridgeAppId,{sequence:t.sequence,chain:t.emitterChain,emitter:t.emitterAddress});try{return await A.checkBitsSet(this.connection,this.tokenBridgeAppId,e.address(),t.sequence)}catch{}return!1}async*createAttestation(t,e){if(!e)throw new Error("Payer required to create attestation");const n=new m(e).toString(),o=new m(t).toInt(),r=[],s=await this.connection.getTransactionParams().do(),a=A.forEmitter(this.coreAppId,new m(this.tokenBridgeAddress).toUint8Array()),{accounts:[p],txs:g}=await O.maybeCreateStorageTx(this.connection,n,this.coreAppId,a,s);r.push(...g);let B="",i;if(o!==0){const I=await this.connection.getAssetByID(o).do(),E=W.from_obj_for_encoding(I),U=await this.connection.accountInformation(E.params.creator).do();if(i=F.from_obj_for_encoding(U),i.authAddr===this.tokenBridgeAddress.toString())throw new Error("Cannot re-attest wormhole assets")}const T=A.forNativeAsset(this.tokenBridgeAppId,BigInt(o)),y=await O.maybeCreateStorageTx(this.connection,n,this.tokenBridgeAppId,T);B=y.accounts[0],r.push(...y.txs);const u=k({from:n,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[f.noop],suggestedParams:s});r.push({tx:u});const h=await this.coreBridge.getMessageFee();if(h>BigInt(0)){const I=S({from:n,suggestedParams:s,to:this.tokenBridgeAddress,amount:h});r.push({tx:I})}let j=[p,B,this.coreAppAddress];i&&j.push(i.address);let d=k({appArgs:[f.attestToken,b.toBytes(o,8)],accounts:j,appIndex:l(this.tokenBridgeAppId),foreignApps:[l(this.coreAppId)],foreignAssets:[o],from:n,onComplete:x.NoOpOC,suggestedParams:s});h>BigInt(0)?d.fee*=3:d.fee*=2,r.push({tx:d});for(const I of r)yield this.createUnsignedTx(I,"TokenBridge.createAttestation",!0)}async*submitAttestation(t,e,n){if(!e)throw new Error("Sender required to submit attestation");n||(n=await this.connection.getTransactionParams().do());const o=e.toString(),r=A.forWrappedAsset(this.tokenBridgeAppId,t.payload.token).address(),s=[],a=[],p=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,r);p.length>8&&a.push(new m(p.slice(0,8)).toInt()),s.push({tx:S({from:o,to:r,amount:1e5,suggestedParams:n})});let g=new Uint8Array(1);g[0]=1,s.push({tx:k({appArgs:[f.noop,g],appIndex:l(this.tokenBridgeAppId),from:o,onComplete:x.NoOpOC,suggestedParams:n})}),g=new Uint8Array(1),g[0]=2,s.push({tx:k({appArgs:[f.noop,g],appIndex:l(this.tokenBridgeAppId),from:o,onComplete:x.NoOpOC,suggestedParams:n})}),s.push({tx:k({accounts:[],appArgs:[f.receiveAttest,D(t)],appIndex:l(this.tokenBridgeAppId),foreignAssets:a,from:o,onComplete:x.NoOpOC,suggestedParams:n})}),s[s.length-1].tx.fee=s[s.length-1].tx.fee*2;for(const B of s)yield this.createUnsignedTx(B,"TokenBridge.submitAttestation",!0)}async*transfer(t,e,n,o,r){const s=t.toString(),a=H(n)?0:new m(n).toInt(),p=o,g=L(e.chain),B=e.address.toUniversalAddress().toUint8Array(),i=await this.connection.getTransactionParams().do(),T=BigInt(0),y=A.fromData({appId:this.coreAppId,appAddress:z(this.coreAppAddress).publicKey,idx:BigInt(0),address:z(this.tokenBridgeAddress).publicKey}),u=[],{accounts:[h],txs:j}=await O.maybeCreateStorageTx(this.connection,s,this.coreAppId,y,i);u.push(...j);let d="",I,E=!1;if(a!==0){const w=await this.connection.getAssetByID(a).do();d=W.from_obj_for_encoding(w).params.creator;const P=await this.connection.accountInformation(d).do();I=F.from_obj_for_encoding(P),E=I.authAddr===this.tokenBridgeAddress.toString()}const U=await this.coreBridge.getMessageFee();if(U>0&&u.push({tx:S({from:s,to:this.tokenBridgeAddress,amount:U,suggestedParams:i})}),!E){const w=A.forNativeAsset(this.tokenBridgeAppId,BigInt(a)),{accounts:[P],txs:R}=await O.maybeCreateStorageTx(this.connection,s,this.tokenBridgeAppId,w,i);d=P,R.push(...R)}if(a!==0&&!await f.isOptedInToAsset(this.connection,d,a)){const w=S({from:s,to:d,amount:1e5,suggestedParams:i});let P=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[f.optIn,se(a,8)],foreignAssets:[a],accounts:[d],suggestedParams:i});P.fee*=2,u.unshift({tx:w},{tx:P})}const Q=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[f.noop],suggestedParams:i});u.push({tx:Q});let _=[];if(a===0){const w=S({from:s,to:d,amount:p,suggestedParams:i});u.push({tx:w}),_=[h,d,d]}else{const w=G({from:s,to:d,amount:p,assetIndex:a,suggestedParams:i});u.push({tx:w}),_=I!=null&&I.address?[h,d,I.address]:[h,d]}const q=[f.sendTransfer,b.toBytes(a,8),b.toBytes(p,8),B,b.toBytes(g,8),b.toBytes(T,8)];r&&q.push(r);const M=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:q,foreignApps:[l(this.coreAppId)],foreignAssets:[a],accounts:_,suggestedParams:i});M.fee*=2,u.push({tx:M});for(const w of u)yield this.createUnsignedTx(w,"TokenBridge.transfer",!0)}async*redeem(t,e,n=!0,o){o||(o=await this.connection.getTransactionParams().do());const r=new m(t).toString(),{accounts:s,txs:a}=await O.submitVAAHeader(this.connection,this.coreAppId,this.tokenBridgeAppId,e,r);let p,g="",B=[],i=0;if(e.payload.token.chain!==this.chain){p=A.forWrappedAsset(this.tokenBridgeAppId,e.payload.token),g=p.address();const h=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,g);i=new m(h.slice(0,8)).toInt()}else{const h=new m(e.payload.token.address).toBigInt();p=A.forNativeAsset(this.tokenBridgeAppId,h),g=p.address(),i=l(h)}s.push(g);let T=0,y="";if(e.payloadName==="TransferWithPayload"?(T=new m(e.payload.to.address).toInt(),y=$(T)):y=new m(e.payload.to.address.toUint8Array()).toString(),s.push(y),i!==0&&(B.push(i),!await f.isOptedInToAsset(this.connection,y,i))){if(r!=y)throw new Error("Cannot ASA optin for somebody else (asset "+i.toString()+")");a.unshift({tx:G({amount:0,assetIndex:i,from:r,suggestedParams:o,to:r})})}const u={accounts:s,appArgs:[f.completeTransfer,D(e)],appIndex:l(this.tokenBridgeAppId),foreignAssets:B,from:r,onComplete:x.NoOpOC,suggestedParams:o};a.push({tx:k(u)}),a[a.length-1].tx.fee=a[a.length-1].tx.fee*(e.payloadName==="Transfer"&&e.payload.fee!==void 0&&e.payload.fee===0n?2:3),e.payloadName==="TransferWithPayload"&&(a[a.length-1].tx.appForeignApps=[T],a.push({tx:k({appArgs:[J.getSelector(),J.args[0].type.encode(D(e))],appIndex:T,foreignAssets:B,from:r,onComplete:x.NoOpOC,suggestedParams:o})}));for(const h of a)yield this.createUnsignedTx(h,"TokenBridge.redeem",!0)}static async isOptedInToAsset(t,e,n){var o;try{const r=await t.accountAssetInformation(e,n).do();return(((o=oe.from_obj_for_encoding(r).assetHolding)==null?void 0:o.amount)??0)>0}catch{}return!1}createUnsignedTx(t,e,n=!0){return new V(t,this.network,this.chain,e,n)}};c(C,"sendTransfer",v.encode("sendTransfer")),c(C,"attestToken",v.encode("attestToken")),c(C,"noop",v.encode("nop")),c(C,"optIn",v.encode("optin")),c(C,"completeTransfer",v.encode("completeTransfer")),c(C,"receiveAttest",v.encode("receiveAttest"));let ie=C;Y(Z,"TokenBridge",ie);export{ie as AlgorandTokenBridge,J as TransferMethodSelector};
