import{bG as H,bH as _,ah as $,aA as L,a as z,E as D,bI as f,bJ as w,bK as x,bL as J,a7 as q,bM as U,bN as j,bO as g,i as M,bP as K,bQ as V,bR as X,bS as Y,bT as Z,_ as tt,u as A,l as G,t as P,q as rt}from"./Bridge.naj9bgy5.js";import"./index-CCzOyXR_.iqftqv4w.js";import"./index.cqjpgwtr.js";import"./vue.fv0erkdm.js";import"./lodash-es.bp0zmem9.js";import"./axios.i01mok01.js";import"./dayjs.pb8a0t5b.js";import"./vuex.jdzbw26m.js";import"./vue-router.jwqkmej7.js";import"./svg-icons.nw66rbkj.js";var et=Object.defineProperty,it=(h,t,r)=>t in h?et(h,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):h[t]=r,c=(h,t,r)=>it(h,typeof t!="symbol"?t+"":t,r);const B=new H(["function start((bytes32,address,address,address,address,address,uint256,uint256,uint256,uint256)) returns (address,uint16,uint64)","function receiveMessageAndSwap(bytes)"]),nt=new H(["function quoteExactInputSingle((address,address,uint256,uint24,uint160)) public view returns (uint256,uint160,uint32,uint256)"]),y=100,ot="https://gfx.relayers.xlabs.xyz/api/v1/swap/quote",at="https://thermae.fly.dev/api/order/create";class Q{static async createOrder(t,r,e,i,n,o,a,s){var m,p;try{const{minAmountStart:d,minAmountFinish:u}=a.swapAmounts,v=w(e),[l,E]=f(t,r,i),[T,k]=f(t,e.chain,o),b=w(E),S=w(k),C=x.get(t,r).portico,I=x.get(t,e.chain).portico,N=$.get(t,r),F=$.get(t,e.chain),W={startingChainId:Number(N),startingToken:b.toLowerCase(),destinationChainId:Number(F),destinationToken:S.toLowerCase(),destinationAddress:v,porticoAddress:C,destinationPorticoAddress:I,startingTokenAmount:n.toString(),minAmountStart:d.toString(),minAmountEnd:u.toString(),bridgeNonce:s,relayerFee:a.relayerFee.toString(),feeTierStart:y,feeTierEnd:y,shouldWrapNative:l,shouldUnwrapNative:T},O=await A.post(at,W);return this.validateCreateOrderResponse(O.data,W),O.data}catch(d){if(A.isAxiosError(d)){const u=`${(m=d.response)==null?void 0:m.statusText}: ${(p=d.response)==null?void 0:p.data.message}`;throw new Error(`Could not create order: ${u},`)}throw d}}static async quoteRelayer(t,r,e){var i;if(G(r)||G(e))throw new Error("how did you get here tho?");const n=P.encode(r.toUniversalAddress().toUint8Array(),!1),o=P.encode(e.toUniversalAddress().toUint8Array(),!1),a={targetChain:q(t),sourceToken:n,targetToken:o};try{const s=await A.post(ot,a);return BigInt(s.data.fee)}catch(s){throw A.isAxiosError(s)?new Error(`Error getting relayer fee: ${(i=s.response)==null?void 0:i.statusText}`):s}}}c(Q,"validateCreateOrderResponse",(h,t)=>{if(!g(t.porticoAddress||"",h.transactionTarget))throw new Error("portico address mismatch");const r=B.decodeFunctionData("start",h.transactionData);if(r.length!==1||r[0].length!==10)throw new Error("decoded length mismatch");const e=P.decode(r[0][0]);if(e.length!==32)throw new Error("flag set length mismatch");const{recipientChain:i,feeTierStart:n,feeTierFinish:o,flags:a}=J.deserializeFlagSet(e),{shouldWrapNative:s,shouldUnwrapNative:m}=a,[p,d]=rt("Evm",BigInt(t.destinationChainId));if(i!==q(d))throw new Error("recipient chain mismatch");if(n!==t.feeTierStart)throw new Error("fee tier start mismatch");if(o!==t.feeTierEnd)throw new Error("fee tier end mismatch");if(!!s!==t.shouldWrapNative)throw new Error("should wrap native mismatch");if(!!m!==t.shouldUnwrapNative)throw new Error("should unwrap native mismatch");const u=r[0][1];if(!g(u,t.startingToken))throw new Error("start token address mismatch");const v=r[0][3];if(!g(v,t.destinationToken))throw new Error("final token address mismatch");const l=r[0][4];if(!g(l,t.destinationAddress))throw new Error("recipient address mismatch");const E=r[0][5];if(!g(E,t.destinationPorticoAddress||""))throw new Error("destination portico address mismatch");if(r[0][6].toString()!==t.startingTokenAmount)throw new Error("amount mismatch");if(r[0][7].toString()!==t.minAmountStart)throw new Error("min amount start mismatch");if(r[0][8].toString()!==t.minAmountEnd)throw new Error("min amount finish mismatch");if(r[0][9].toString()!==t.relayerFee)throw new Error("relayer fee mismatch")});class R{constructor(t,r,e,i){if(c(this,"network"),c(this,"chain"),c(this,"provider"),c(this,"contracts"),c(this,"chainId"),c(this,"porticoAddress"),c(this,"uniswapAddress"),c(this,"porticoContract"),c(this,"uniswapContract"),c(this,"core"),this.network=t,this.chain=r,this.provider=e,this.contracts=i,!i.portico)throw new Error("Unsupported chain, no contract addresses for: "+r);this.core=new _(t,r,e,i);const{portico:n,uniswapQuoterV2:o}=i.portico;this.porticoAddress=n,this.uniswapAddress=o,this.chainId=$.get(t,r),this.porticoContract=new L(this.porticoAddress,B.fragments,this.provider),this.uniswapContract=new L(this.uniswapAddress,nt.fragments,this.provider)}static async fromRpc(t,r){const[e,i]=await z.chainFromRpc(t),n=r[i];if(n.network!==e)throw new Error(`Network mismatch: ${n.network} != ${e}`);return new R(e,i,t,n.contracts)}async*transfer(t,r,e,i,n,o){const{minAmountStart:a,minAmountFinish:s}=o.swapAmounts;if(a===0n)throw new Error("Invalid min swap amount");if(s===0n)throw new Error("Invalid min swap amount");const m=new D(t).toString(),[p,d]=f(this.network,this.chain,e),[u,v]=f(this.network,r.chain,n),l=w(d),E=w(this.getTransferrableToken(l)),T=w(r),k=w(v),b=x.get(this.network,r.chain).portico,S=new Date().valueOf()%2**4,C=J.serializeFlagSet({flags:{shouldWrapNative:p,shouldUnwrapNative:u},recipientChain:q(r.chain),bridgeNonce:S,feeTierStart:y,feeTierFinish:y,padding:new Uint8Array(19)}),I=B.encodeFunctionData("start",[[C,l.toLowerCase(),E,k.toLowerCase(),T,b,i.toString(),a.toString(),s.toString(),o.relayerFee.toString()]]);p||(yield*this.approve(l,m,i,this.porticoAddress));const N=await this.core.getMessageFee(),F={to:this.porticoAddress,data:I,value:N+(p?i:0n)};yield this.createUnsignedTransaction(U(F,m),"PorticoBridge.Transfer")}async*redeem(t,r){const e=await this.porticoContract.getFunction("receiveMessageAndSwap").populateTransaction(j(r)),i=new D(t).toString();yield this.createUnsignedTransaction(U(e,i),"PorticoBridge.Redeem")}async quoteSwap(t,r,e){const[,i]=f(this.network,this.chain,t),[,n]=f(this.network,this.chain,r),o=w(i),a=w(n);return g(o,a)?e:(await this.uniswapContract.getFunction("quoteExactInputSingle").staticCall([o,a,e,y,0]))[0]}async quoteRelay(t,r){return await Q.quoteRelayer(this.chain,t,r)}getTransferrableToken(t){var r;if(this.chain==="Ethereum")return M.tokenId("Ethereum",t);const e=K(this.network,this.chain,t);if(!e)throw new Error("Unsupported source token: "+t);const i=(r=V(this.network,this.chain,e.symbol))==null?void 0:r.find(n=>n.original==="Ethereum");if(!i)throw new Error(`Unsupported symbol for chain ${e.symbol}: ${this.chain} `);return M.tokenId(i.chain,i.address)}async*approve(t,r,e,i){const n=z.getTokenImplementation(this.provider,t);if(await n.allowance(r,i)<e){const o=await n.approve.populateTransaction(i,e);yield this.createUnsignedTransaction(U(o,r),"PorticoBridge.Approve")}}createUnsignedTransaction(t,r){return new X(Y(t,this.chainId),this.network,this.chain,r,!1)}}Z(tt,"PorticoBridge",R);export{R as EvmPorticoBridge};
